# Модуль D₁.₁ — дочернее ядро аналитической ветки

## 1. Общее назначение и положение в архитектуре
Модуль **D₁.₁** является когнитивным ядром аналитической ветви экосистемы `C₁ → CMV₁ → M₁.₁ → D₁.₁ → S₁.₁.k`. Он функционирует исключительно через модуль связи **M₁.₁**, который обеспечивает транспорт, безопасность и маршрутизацию. Прямые соединения с исполнителями **S₁.₁.k** недопустимы.

Основные обязанности D₁.₁:
- семантический анализ входящих задач аналитического профиля;
- планирование и маршрутизация вычислений через M₁.₁;
- контроль SLA и управление самовосстановлением;
- предиктивные push-операции для ускорения выдачи результатов;
- ведение когнитивного контура SLA/Sandbox/Replay.

## 2. Пятиуровневая модель взаимодействий

| План | Назначение | Протокол | Endpoint |
|------|------------|----------|----------|
| Data Plane | Приём задач и выдача результатов | HTTP/2 + JSON | `/execute`, `/status/{task_id}` |
| Control Plane | Управление режимами работы | WebSocket `/ctrl` | слушатель команд CMV₁ |
| Predictive Plane | Серверный push прогнозируемых данных | HTTP/2 Server Push | `/push/{task_id}` |
| Reliability Plane | SLA-контур, самовосстановление | MRP / Watchdog | `/metrics`, MRP события |
| Semantic Plane | Семантическое планирование и адаптация | внутренний GraphQL/JSON | `semantic://` (внутренний bus) |

## 3. Топология потоков

1. **CMV₁** инициирует задачи и команды → направляет их через **M₁.₁**.
2. **M₁.₁** выполняет валидацию (JWT, CRC), нормализацию и пересылает payload на `/execute` D₁.₁.
3. **D₁.₁** обрабатывает задачу, выбирает маршрут `S₁.₁.k` через планировщик и возвращает результаты обратно в M₁.₁.
4. Предиктивные push-ответы отправляются D₁.₁ на M₁.₁ для ускорения будущих запросов.
5. SLA-метрики, логи MRP и сигналы самовосстановления доставляются в CMV₁ через M₁.₁.

```
C₁ → CMV₁ → M₁.₁ ⇆ D₁.₁ ⇆ M₁.₁ → S₁.₁.k
```

## 4. Логические уровни ядра D₁.₁

### 4.1 L1 — Diagnostic Layer
- Проверка CRC, JWT подписи и контракта.
- Сообщение о повреждённых данных в MRP (`TaskIntegrityError`).

### 4.2 L2 — Semantic Planning Layer
- Определение `intent`, `mode`, `context` задачи.
- Формирование планов: выбор типа исполнителя `S₁.₁.k`, параметров точности, политики кеша.

### 4.3 L3 — Execution Layer
- Асинхронное выполнение через HTTP/2 вызовы M₁.₁ Router API.
- SLA контроль: фиксирует latency, ошибки, тайм-ауты, управляет retries.

### 4.4 L4 — Predictive Push Layer
- Анализ истории задач (reuse_rate, waste_rate, latency_avg).
- Решение об отправке push (schema, cached result, SLA hints).
- Поддержка режима `BOOST_PUSH` из control-plane.

### 4.5 L5 — Feedback & Reliability Layer
- Отчёты SLA, метрики Prometheus, события MRP.
- Поддержка когнитивного цикла SLA/Sandbox/Replay.
- Watchdog (heartbeat каждые 15 секунд, timeout 45 секунд) с `trigger_self_heal`.

## 5. Классовая структура (каркас)

```python
class D_1_1:
    def __init__(self, redis_url="redis://localhost"):
        self.redis_url = redis_url
        self.cache = RedisCache(redis_url)
        self.router = AnalyticalRouter()
        self.executor = AnalyticalExecutor(self.router)
        self.predictor = PushPredictor()
        self.metrics = Metrics()
        self.diagnostics = DiagnosticL1()
        self.semantic = SemanticController()
        self.mrp = MRP("D_1.1")
        self.watchdog = Watchdog(check_interval=15, timeout=45, callback=self._self_heal)

    async def handle_execute(self, payload: dict) -> dict:
        self.diagnostics.validate(payload)
        task = self.semantic.enrich(payload)
        route = self.router.decide_route(task)
        plan = self.executor.prepare_plan(task, route)
        result = await self.executor.run(plan)
        await self._handle_predictive_push(task, result)
        self.metrics.track(task, result)
        self.mrp.log("TaskCompleted", {"task_id": task["task_id"], "latency": result["latency"]})
        return OutputFormatter.format(result)

    async def _handle_predictive_push(self, task, result):
        decision = self.predictor.should_push(task)
        if decision.push:
            await self.predictor.execute_push(task, result)

    async def _self_heal(self, reason: str):
        self.mrp.log("SelfHealTriggered", {"reason": reason}, level="WARNING")
        os.execv(sys.executable, [sys.executable] + sys.argv)
```

### 5.1 Подсистемы

| Компонент | Назначение |
|-----------|------------|
| `DiagnosticL1` | CRC, контракт, интегритет, отчёты в MRP |
| `AnalyticalRouter` | Выбор исполнителя `S₁.₁.k` по типу задачи |
| `AnalyticalExecutor` | Подготовка и исполнение планов, SLA-контроль |
| `PushPredictor` | История latency, решение о push |
| `SemanticController` | Интерпретация `intent`, адаптация параметров |
| `RedisCache` | `task:{id}:result`, `task:{id}:meta`, `task:{id}:push_state` |
| `Metrics` | Prometheus метрики + SLA журнал |
| `Watchdog` | Мониторинг жизнеспособности |

## 6. Контракты Data Plane

### 6.1 Входной payload `/execute`
```json
{
  "task_id": "UUID",
  "task_type": "KPI | Graphs | Tables | Reports | Forecasts",
  "input": {"region": "EU", "period": "monthly"},
  "context": {"user_priority": "high"},
  "crc": 123456789
}
```

### 6.2 Ответ D₁.₁ → M₁.₁
```json
{
  "task_id": "UUID",
  "status": "completed | failed | revoked",
  "result": {"avg_revenue": 138420.2, "growth_rate": 0.12},
  "latency": 1.43,
  "sla": {"state": "normal", "breach": false},
  "crc": 987654321
}
```

### 6.3 Эндпоинты

| Endpoint | Метод | Назначение |
|----------|-------|------------|
| `/execute` | POST | Приём задач |
| `/status/{task_id}` | GET | Состояние задачи из `RedisCache` |
| `/push/{task_id}` | GET | Принудительный push подготовленных данных |
| `/metrics` | GET | Метрики Prometheus |
| `/ctrl` | WebSocket | Прослушивание команд CMV₁ |

## 7. Control Plane и команды

`/ctrl` принимает JSON-команды:

| Команда | Действие |
|---------|----------|
| `THROTTLE` | `set_rate_limit(value)` — замедлить обработку |
| `RESET` | Очистка кеша, сброс метрик, перезапуск планировщика |
| `REVOKE_TASK` | `cancel_task(task_id)` — остановка выполнения |
| `BOOST_PUSH` | Усиление предиктивного push |
| `ANALYZE_LATENCY` | Формирование SLA отчёта и передача в CMV₁ |

## 8. Predictive Server Push

- История задач ведётся в `d1_1:predict:*` (Redis).
- При `reuse_rate > 0.6` и `waste_rate < 0.2` push активируется.
- Типы push-ресурсов: `schema`, `last_result`, `sla_snapshot`, `context_hint`.
- Используется HTTP/2 `PUSH_PROMISE` с заголовками `X-Predictive-Task`.

```python
if predictor.should_push(task_type):
    await push.send(
        resource="/prefetch/last_result.json",
        payload=cache.get_last_result(task_id),
        headers={"X-Task-ID": task_id}
    )
```

## 9. SLA и самовосстановление

- **SLA нормальное состояние:** latency ≤ 3.0 s.
- **SLA предупреждение:** latency > 3.0 s → `mrp.log("SLAWarning", {...})`.
- **SLA нарушение:** latency > 5.0 s → `mrp.log("SLA_Breach", {...})`, автоматический retry.
- Watchdog вызывает `trigger_self_heal` при `timeout > 45 s` или `error_rate > 5%`.
- Каждые 5 минут D₁.₁ публикует отчёт SLA в CMV₁ через M₁.₁.

## 10. Sandbox/Replay контур

- **Sandbox режим:** задачи помечаются `context.mode = "sandbox"`, результаты не влияют на основную статистику.
- **Replay режим:** `/replay/{task_id}` инициирует повторное выполнение с сохранением первоначального контекста.
- Контур управляется командами control-plane (`ENTER_SANDBOX`, `EXIT_SANDBOX`).

## 11. Безопасность и ограничения

1. Все входящие сообщения подписаны JWT M₁.₁.
2. CRC обязательна для каждой транзакции.
3. Максимум параллельных задач: 10 (настраивается `THROTTLE`).
4. Никаких внешних сетевых соединений, кроме обратного канала в M₁.₁.
5. Долговременное хранение запрещено — только кеш Redis.

## 12. Метрики и логирование

| Метрика | Описание |
|---------|----------|
| `d1_1_task_latency_seconds` | Гистограмма латентности |
| `d1_1_push_success_ratio` | Доля полезных push |
| `d1_1_sla_violation_total` | Количество нарушений SLA |
| `d1_1_predictive_accuracy` | Эффективность предсказаний |

MRP события:
- `TaskReceived`, `TaskPlanned`, `ExecutorAssigned`, `PushPredicted`, `PushDelivered`, `SLA_Breach`, `SelfHealTriggered`, `SandboxEntered`, `ReplayStarted`.

## 13. План реализации

1. **Каркас**: настроить асинхронный сервер (FastAPI/Quart/AnyIO) с поддержкой HTTP/2.
2. **Data Plane**: реализовать `/execute`, `/status`, `/metrics` с интеграцией Redis.
3. **Control Plane**: подключение к `/ctrl` CMV₁ (WebSocket), обработка команд.
4. **Execution Core**: маршрутизация, SLA-контур, взаимодействие с M₁.₁ Router.
5. **Predictive Push**: реализация `PushPredictor`, хранение истории, HTTP/2 push.
6. **Reliability**: Watchdog, self-heal, отчёты MRP, sandbox/replay.
7. **Тестирование**: контрактные тесты с M₁.₁, нагрузочные тесты push, SLA симуляции.

## 14. Критерии готовности

- Совместимость с протоколами M₁.₁ подтверждена контрактными тестами.
- Среднее время выполнения ≤ 3 с, точность push ≥ 80%.
- Автовосстановление проходит без вмешательства оператора.
- Все команды control-plane корректно применяются и журналируются.

---

Документ служит подробной инструкцией для команды разработки по созданию когнитивного дочернего ядра D₁.₁, полностью интегрированного в дуальную архитектуру CMV₁ ↔ M₁.₁ и способного к самостоятельной адаптации, прогнозированию и поддержанию SLA.
